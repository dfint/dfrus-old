-- Текущая версия патча

include std/console.e
include std/filesys.e
include std/search.e
include std/get.e
include std/sequence.e

-- with trace
include patcher.e
include pe.e
include disasm.e

global integer debug = 0
include patchdf.e

sequence path = ""
sequence cmd = command_line()

debug = find("debug",cmd)
if debug then
    cmd = remove(cmd,debug)
    debug = 1
end if

if length(cmd)>2 then
    path = cmd[3]
end if

constant df1 = path & "Dwarf Fortress.exe"
constant df2 = path & "Dwarf Fortress Rus.exe"
atom fn, pe_header

-----------------------------------------------------------------------------
puts(1,"Checking timedate stamp... ")
constant DF03125SDL_stamp = #4D90764F
fn = open_pe(df1)
if fn < 0 then
    printf(1,"\nUnable to open \"%s\"\n",{df1})
    any_key()
    abort(1)
end if

pe_header = check_pe(fn)
constant timedate = fpeek4u(fn, pe_header+PE_TIMEDATE_STAMP)
close(fn)
if timedate != DF03125SDL_stamp then
    puts(1,"\nWrong timedate stamp. The patcher works with DF 0.31.25 SDL only.\n")
    any_key()
    abort(1)
else
    puts(1,"OK\n")
end if

-----------------------------------------------------------------------------
printf(1,"Copying \"%s\"\nTo \"%s\"... ",{df1,df2})
if not copy_file(df1,df2,1) then
    puts(1,"Failed.\n")
    any_key()
    abort(1)
else
    puts(1,"Success.\n")
end if

fn = open_pe(df2)

-----------------------------------------------------------------------------
puts(1,"Enabling the cyrillic alphabet...\n")

fpoke(fn, #2F07DC, MOVZX) -- исправление MOVSX на MOVZX
fpoke(fn, #2F063E, MOVZX) -- исправление MOVSX на MOVZX
patch_unicode_table(fn, #7338D8)

-----------------------------------------------------------------------------
puts(1,"Loading translation file... ")

constant trans_filename = "trans.txt"
object trans = load_trans_file(trans_filename)
if atom(trans) then
    close(fn)
    printf(1,"Failed.\n%s file not found.\n",{trans_filename})
    any_key()
    abort(-1)
else
    printf(1,"%d strings loaded.\n", length(trans))
end if

function second(sequence s)
    return s[2]
end function

if debug and length(cmd)>=5 then
    trans = trans[second(value(cmd[4]))..second(value(cmd[5]))]
    printf(1,"From %x to %x total %d\n",{trans[1][1],trans[$][1],length(trans)})
end if

-----------------------------------------------------------------------------
puts(1,"Finding cross-referencess...\n")

pe_header = check_pe(fn) -- todo: проверка валидности

constant
    image_base = fpeek4u(fn, pe_header+PE_IMAGE_BASE),
    sections = get_section_table(fn, pe_header)

-- Получаем адреса всех перемещаемых элементов:
sequence
    relocs = get_relocations(fn,sections),
-- Получаем перекрёстные ссылки:
    xref_table = get_cross_references(fn,relocs,sections,image_base),
    objs  = xref_table[1],
    xrefs = xref_table[2]

-----------------------------------------------------------------------------
-- puts(1,"Preparing additional data section...\n")
-- Подготовка дополнительной секции данных

constant
    file_alignment = fpeek4u(fn,pe_header+PE_FILE_ALIGNMENT),
    section_alignment = fpeek4u(fn,pe_header+PE_SECTION_ALIGNMENT)

-- "Прототип" новой секции:
sequence new_section = {
    ".rus",
    0, -- Virtual Size
    align(sections[$][SECTION_RVA]+sections[$][SECTION_VSIZE],
        section_alignment), -- RVA -- выровнять под #1000
    0, -- Phisical Size
    align(sections[$][SECTION_POFFSET] + sections[$][SECTION_PSIZE],
        file_alignment), -- Phisical Offset -- Выровнять под #200
    0,0,0,0, -- reserved
    IMAGE_SCN_CNT_INITIALIZED_DATA + IMAGE_SCN_MEM_READ -- readable data
}

atom str_off = new_section[SECTION_POFFSET]

-----------------------------------------------------------------------------
puts(1,"Translating...\n")

sequence s, pre, mach
integer aligned = 0, k, l, extra, delta, start, long
object x

for i = 1 to length(trans) do
    if equal(trans[i][2], trans[i][3]) then
        continue -- Если перевод равен оригиналу, то пропускаем
    end if
    
    -- Поиск строки в таблице объектов:
    k = binary_search(trans[i][1],objs)
    if k <= 0 then
        if debug then
            printf(1, "Warning: References to string at %x offset not found.\n", trans[i][1])
        end if
        continue
    end if
    s = xrefs[k] -- список ссылок на данную строку
    
    -- Находим ссылки на середину строки
    l = 1
    while objs[k+l]-trans[i][1] < length(trans[i][2])+1 do
        for j = 1 to length(s) do
            delta =  s[j] - xrefs[k+l][1]
            if length(xrefs[k+l]) = 1 and delta>0 and delta<=6 then
                s[j] = xrefs[k+l][1]
            end if
        end for
        l += 1
    end while
    
    if length(trans[i][2])>=length(trans[i][3]) then
        -- Прописать перевод поверх оригинала
        for j=1 to length(s) do
            fix_len(fn, s[j], length(trans[i][2]), length(trans[i][3]))
        end for
        extra = length(trans[i][2])-length(trans[i][3]) -- количество незадействованных байт
        fpoke(fn, trans[i][1], trans[i][3] & repeat(0, extra+1)) -- назадействованные байты заполнить нулями
    else
        long = align(length(trans[i][2])+1)<length(trans[i][3])+1
        if not long then
            -- Если строка достаточно короткая, то записать ее поверх старой:
            fpoke(fn, trans[i][1], trans[i][3] & 0)
        else
            -- Если строка длинная, то записать ее в специально отведенную для этого секцию:
            str_off += aligned
            aligned = align(length(trans[i][3])+1)
            fpoke(fn, str_off, pad_tail(trans[i][3], aligned, 0))
        end if
        
        for j = 1 to length(s) do
            -- Исправить длину строки:
            if fix_len(fn, s[j], length(trans[i][2]), length(trans[i][3])) then
                if long then -- Если строка длинная,
                    -- то исправить ссылку на строку в коде:
                    fix_off(fn, s[j], off_to_rva_ex(str_off, new_section)+image_base)
                end if
            else -- Если не удалось исправить длину:
                -- Считываем 3 байта перед ссылкой для нахождения начала копирующего кода
                pre = fpeek(fn, {s[j]-3, 3})
                -- Находим начало копирующего кода:
                start = s[j]-get_start(pre)
                -- Получаем длину кода, копирующего строку:
                x = get_length( fpeek(fn, {start, 100}), length(trans[i][2])+1)
                
                if sequence(x) then
                    -- Получаем машинный код, копирующий строку:
                    mach = mach_memcpy(off_to_rva_ex(str_off, new_section)+image_base, x[2], length(trans[i][3])+1)
                    if sequence(x[4]) then
                        mach &= lea(x[4][1],x[4][2..3])
                    end if
                    if length(mach) > x[1] then
                        -- todo: записывать mach в новую секцию, а на месте записывать вызов этого кода.
                        if debug then
                            printf(1,"%x|%s|%s| <- %x (%x)\n",
                                trans[i][1..3] & s[j] & ( off_to_rva_ex(s[j], sections[1])+image_base ) )
                            printf(1, "Mach code is too long (%d against %d).\n",{length(mach),x[1]})
                        end if
                        continue -- полученный машинный код не уместился
                    end if
                    mach = pad_tail(mach, x[1], NOP) -- добиваем освободившиеся байты пустыми командами
                    fpoke(fn, start, mach) -- патчим код!
                    -- Исправляем битые релокации --
                    -- Преобразуем смещение начала измененного кода в его относительный адрес:
                    start = off_to_rva_ex(start, sections[1])
                    x[3] += start-1 -- получаем адреса удаленных ссылок
                    if modify_relocations(fn, sections, (-x[3]) & (start+new_ref_off)) != 0 and debug then
                        printf(1,"%x|%s|%s| <- %x (%x)\n",
                            trans[i][1..3] & s[j] & ( off_to_rva_ex(s[j], sections[1])+image_base ) )
                        puts(1, "Failed to fix relocations.\n")
                    end if
                elsif debug then
                    printf(1,"%x|%s|%s| <- %x (%x)\n",
                        trans[i][1..3] & s[j] & ( off_to_rva_ex(s[j], sections[1])+image_base ) )
                    printf(1,"Failed to obtain copying code length (Error code %d).\n",x)
                end if
            end if
        end for
    end if
end for
str_off+=aligned

-----------------------------------------------------------------------------
-- Физическое добавление новой секции

-- Выровнять физический размер секции и файла под #200
atom file_size = align(str_off, file_alignment)
new_section[SECTION_PSIZE] = file_size - new_section[SECTION_POFFSET]

-- Создавать новую секцию только при ненулевом ее размере:
if new_section[SECTION_PSIZE] > 0 then
    puts(1,"Adding new data section...\n")
    
    -- Выровнять размер файла:
    seek(fn,file_size-1)
    puts(fn,0)

    -- Виртуальный размер секции, выравнивать не нужно:
    new_section[SECTION_VSIZE] = str_off - new_section[SECTION_POFFSET] 

    -- Записать информацию о секции: 
    put_section_info(fn,
        pe_header + SIZEOF_PE_HEADER + length(sections)*SIZEOF_IMAGE_SECTION_HEADER,
        new_section)

    -- Исправить значение поля количества секций:
    fpoke2(fn, pe_header + PE_NUMBER_OF_SECTIONS, length(sections)+1)

    -- Изменить поле ImageSize PE-заголовка с учетом новой секции и выровнять под #1000:
    fpoke4(fn, pe_header + PE_SIZE_OF_IMAGE,
        align(new_section[SECTION_RVA] + new_section[SECTION_VSIZE],
            section_alignment))
end if

close(fn)

puts(1,"Done.\n")
any_key()
